--- a/include/net/cfg80211.h	2008-02-28 19:54:52.000000000 +0100
+++ b/include/net/cfg80211.h	2008-02-28 19:54:53.000000000 +0100
@@ -7,6 +7,7 @@
 #include <net/genetlink.h>
 /* remove once we remove the wext stuff */
 #include <net/iw_handler.h>
+#include <net/compat.h>
 
 /*
  * 802.11 configuration in-kernel interface
--- a/net/wireless/Makefile	2008-10-27 19:54:52.000000000 +0100
+++ b/net/wireless/Makefile	2008-10-27 19:54:53.000000000 +0100
@@ -1,10 +1,9 @@
-obj-$(CONFIG_WIRELESS_EXT) += wext.o
 obj-$(CONFIG_CFG80211) += cfg80211.o
 obj-$(CONFIG_LIB80211) += lib80211.o
 obj-$(CONFIG_LIB80211_CRYPT_WEP) += lib80211_crypt_wep.o
 obj-$(CONFIG_LIB80211_CRYPT_CCMP) += lib80211_crypt_ccmp.o
 obj-$(CONFIG_LIB80211_CRYPT_TKIP) += lib80211_crypt_tkip.o
 
-cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o
+cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o compat.o
 cfg80211-$(CONFIG_WIRELESS_EXT) += wext-compat.o
 cfg80211-$(CONFIG_NL80211) += nl80211.o
--- a/drivers/net/wireless/zd1211rw/zd_chip.h	2008-03-07 20:02:06.000000000 -0500
+++ b/drivers/net/wireless/zd1211rw/zd_chip.h	2008-03-07 20:02:07.000000000 -0500
@@ -897,7 +897,7 @@
 int zd_chip_unlock_phy_regs(struct zd_chip *chip);
 
 enum led_status {
-	LED_OFF = 0,
+	LED_OFF_ZD = 0,
 	LED_SCANNING = 1,
 	LED_ASSOCIATED = 2,
 };
--- a/drivers/net/usb/Makefile	2008-10-27 09:41:27.000000000 -0700
+++ b/drivers/net/usb/Makefile	2008-10-27 09:43:01.000000000 -0700
@@ -2,21 +2,7 @@
 # Makefile for USB Network drivers
 #
 
-obj-$(CONFIG_USB_CATC)		+= catc.o
-obj-$(CONFIG_USB_KAWETH)	+= kaweth.o
-obj-$(CONFIG_USB_PEGASUS)	+= pegasus.o
-obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
-obj-$(CONFIG_USB_HSO)		+= hso.o
-obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
-obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
-obj-$(CONFIG_USB_NET_SMSC95XX)	+= smsc95xx.o
-obj-$(CONFIG_USB_NET_GL620A)	+= gl620a.o
-obj-$(CONFIG_USB_NET_NET1080)	+= net1080.o
-obj-$(CONFIG_USB_NET_PLUSB)	+= plusb.o
 obj-$(CONFIG_USB_NET_RNDIS_HOST)	+= rndis_host.o
-obj-$(CONFIG_USB_NET_CDC_SUBSET)	+= cdc_subset.o
-obj-$(CONFIG_USB_NET_ZAURUS)	+= zaurus.o
-obj-$(CONFIG_USB_NET_MCS7830)	+= mcs7830.o
 obj-$(CONFIG_USB_USBNET)	+= usbnet.o
 
diff --git a/drivers/net/wireless/b43/pcmcia.c b/drivers/net/wireless/b43/pcmcia.c
index 3cfc303..33c76b0 100644
--- a/drivers/net/wireless/b43/pcmcia.c
+++ b/drivers/net/wireless/b43/pcmcia.c
@@ -87,7 +87,11 @@ static int __devinit b43_pcmcia_probe(struct pcmcia_device *dev)
 	res = pcmcia_get_tuple_data(dev, &tuple);
 	if (res != 0)
 		goto err_kfree_ssb;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	res = pcmcia_parse_tuple(NULL,&tuple, &parse);
+#else
 	res = pcmcia_parse_tuple(&tuple, &parse);
+#endif
 	if (res != 0)
 		goto err_kfree_ssb;
 
diff --git a/drivers/net/wireless/libertas/if_cs.c b/drivers/net/wireless/libertas/if_cs.c
index 842a08d..079c1fd 100644
--- a/drivers/net/wireless/libertas/if_cs.c
+++ b/drivers/net/wireless/libertas/if_cs.c
@@ -791,7 +791,11 @@ static int if_cs_probe(struct pcmcia_device *p_dev)
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	if ((ret = pcmcia_get_first_tuple(p_dev, &tuple)) != 0 ||
 	    (ret = pcmcia_get_tuple_data(p_dev, &tuple)) != 0 ||
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	    (ret = pcmcia_parse_tuple(NULL,&tuple, &parse)) != 0)
+#else
 	    (ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+#endif
 	{
 		lbs_pr_err("error in pcmcia_get_first_tuple etc\n");
 		goto out1;
diff --git a/net/mac80211/wme.c b/net/mac80211/wme.c
index a0c860f..9c6f214 100644
--- a/net/mac80211/wme.c
+++ b/net/mac80211/wme.c
@@ -124,6 +124,7 @@ u16 ieee80211_select_queue(struct net_device *dev, struct sk_buff *skb)
 	if (unlikely(queue >= local->hw.queues))
 		queue = local->hw.queues - 1;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 	if (skb->requeue) {
 		if (!hw->ampdu_queues)
 			return queue;
@@ -142,6 +143,7 @@ u16 ieee80211_select_queue(struct net_device *dev, struct sk_buff *skb)
 
 		return queue;
 	}
+#endif
 
 	/* Now we know the 1d priority, fill in the QoS header if
 	 * there is one.
--- a/drivers/net/wireless/Makefile	2008-11-10 12:55:55.000000000 -0800
+++ b/drivers/net/wireless/Makefile	2008-11-10 12:57:30.000000000 -0800
@@ -5,41 +5,14 @@
 obj-$(CONFIG_IPW2100) += ipw2x00/
 obj-$(CONFIG_IPW2200) += ipw2x00/
 
-obj-$(CONFIG_STRIP) += strip.o
-obj-$(CONFIG_ARLAN) += arlan.o 
-
-arlan-objs := arlan-main.o arlan-proc.o
-
-# Obsolete cards
-obj-$(CONFIG_WAVELAN)		+= wavelan.o
-obj-$(CONFIG_PCMCIA_NETWAVE)	+= netwave_cs.o
-obj-$(CONFIG_PCMCIA_WAVELAN)	+= wavelan_cs.o
-
-obj-$(CONFIG_HERMES)		+= orinoco/
-
-obj-$(CONFIG_AIRO)		+= airo.o
-obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
-
-obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
-obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
-
-obj-$(CONFIG_PRISM54)		+= prism54/
-
-obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
 obj-$(CONFIG_RTL8180)		+= rtl818x/
 obj-$(CONFIG_RTL8187)		+= rtl818x/
 
-# 16-bit wireless PCMCIA client drivers
-obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
-obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
-
 obj-$(CONFIG_USB_NET_RNDIS_WLAN)	+= rndis_wlan.o
 
-obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
 obj-$(CONFIG_LIBERTAS)		+= libertas/
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
--- a/drivers/misc/eeprom/Makefile	2009-01-22 07:51:17.000000000 -0800
+++ b/drivers/misc/eeprom/Makefile	2009-01-22 07:51:26.000000000 -0800
@@ -1,4 +1 @@
-obj-$(CONFIG_EEPROM_AT24)	+= at24.o
-obj-$(CONFIG_EEPROM_AT25)	+= at25.o
-obj-$(CONFIG_EEPROM_LEGACY)	+= eeprom.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
--- a/drivers/net/wireless/zd1211rw/zd_chip.c	2009-01-15 16:35:33.000000000 -0800
+++ b/drivers/net/wireless/zd1211rw/zd_chip.c	2009-01-15 16:35:33.000000000 -0800
@@ -1278,7 +1278,7 @@
 	other_led = chip->link_led == LED1 ? LED2 : LED1;
 
 	switch (status) {
-	case LED_OFF:
+	case LED_OFF_ZD:
 		ioreqs[0].value = FW_LINK_OFF;
 		ioreqs[1].value = v[1] & ~(LED1|LED2);
 		break;
--- a/drivers/net/wireless/zd1211rw/zd_mac.c	2009-01-15 16:35:33.000000000 -0800
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c	2009-01-15 16:35:33.000000000 -0800
@@ -1031,5 +1031,5 @@
 	dev_dbg_f(zd_mac_dev(mac), "\n");
 	cancel_rearming_delayed_workqueue(zd_workqueue,
 		&mac->housekeeping.link_led_work);
-	zd_chip_control_leds(&mac->chip, LED_OFF);
+	zd_chip_control_leds(&mac->chip, LED_OFF_ZD);
 }
--- a/net/mac80211/main.c	2009-01-23 12:56:18.000000000 -0800
+++ b/net/mac80211/main.c	2009-01-23 12:56:24.000000000 -0800
@@ -485,6 +485,7 @@
 		return;
 	}
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 	if (!test_sta_flags(sta, WLAN_STA_PS) && !skb->requeue) {
 		/* Software retry the packet once */
 		skb->requeue = 1;
@@ -492,6 +493,7 @@
 		dev_queue_xmit(skb);
 		return;
 	}
+#endif
 
 #ifdef CONFIG_MAC80211_VERBOSE_DEBUG
 	if (net_ratelimit())
--- a/net/mac80211/rx.c	2009-01-15 16:35:33.000000000 -0800
+++ b/net/mac80211/rx.c	2009-01-15 16:35:33.000000000 -0800
@@ -780,12 +780,17 @@
 
 	/* Send all buffered frames to the station */
 	while ((skb = skb_dequeue(&sta->tx_filtered)) != NULL) {
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28))
+		dev_kfree_skb(skb);
+#else
 		sent++;
 		skb->requeue = 1;
 		dev_queue_xmit(skb);
+#endif
 	}
 	while ((skb = skb_dequeue(&sta->ps_tx_buf)) != NULL) {
 		local->total_ps_buffered--;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 		sent++;
 #ifdef CONFIG_MAC80211_VERBOSE_PS_DEBUG
 		printk(KERN_DEBUG "%s: STA %pM aid %d send PS frame "
@@ -794,6 +799,9 @@
 #endif /* CONFIG_MAC80211_VERBOSE_PS_DEBUG */
 		skb->requeue = 1;
 		dev_queue_xmit(skb);
+#else
+		dev_kfree_skb(skb);
+#endif
 	}
 
 	return sent;
--- a/drivers/net/b44.c	2009-01-22 07:52:14.000000000 -0800
+++ b/drivers/net/b44.c	2009-01-22 07:52:14.000000000 -0800
@@ -846,6 +846,9 @@
 static int b44_poll(struct napi_struct *napi, int budget)
 {
 	struct b44 *bp = container_of(napi, struct b44, napi);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	struct net_device *netdev = bp->dev;
+#endif
 	int work_done;
 
 	spin_lock_irq(&bp->lock);
@@ -874,7 +877,11 @@
 	}
 
 	if (work_done < budget) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+		netif_rx_complete(netdev, napi);
+#else
 		netif_rx_complete(napi);
+#endif
 		b44_enable_ints(bp);
 	}
 
@@ -906,13 +913,21 @@
 			goto irq_ack;
 		}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+		if (netif_rx_schedule_prep(dev, &bp->napi)) {
+#else
 		if (netif_rx_schedule_prep(&bp->napi)) {
+#endif
 			/* NOTE: These writes are posted by the readback of
 			 *       the ISTAT register below.
 			 */
 			bp->istat = istat;
 			__b44_disable_ints(bp);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+			__netif_rx_schedule(dev, &bp->napi);
+#else
 			__netif_rx_schedule(&bp->napi);
+#endif
 		} else {
 			printk(KERN_ERR PFX "%s: Error, poll already scheduled\n",
 			       dev->name);
@@ -2108,6 +2123,7 @@
 	return err;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops b44_netdev_ops = {
 	.ndo_open		= b44_open,
 	.ndo_stop		= b44_close,
@@ -2123,6 +2139,7 @@
 	.ndo_poll_controller	= b44_poll_controller,
 #endif
 };
+#endif
 
 static int __devinit b44_init_one(struct ssb_device *sdev,
 				  const struct ssb_device_id *ent)
@@ -2162,9 +2179,26 @@
 	bp->rx_pending = B44_DEF_RX_RING_PENDING;
 	bp->tx_pending = B44_DEF_TX_RING_PENDING;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	dev->open = b44_open;
+	dev->stop = b44_close;
+	dev->hard_start_xmit = b44_start_xmit;
+	dev->get_stats = b44_get_stats;
+	dev->set_multicast_list = b44_set_rx_mode;
+	dev->set_mac_address = b44_set_mac_addr;
+	dev->do_ioctl = b44_ioctl;
+	dev->tx_timeout = b44_tx_timeout;
+	netif_napi_add(dev, &bp->napi, b44_poll, 64);
+	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = b44_poll_controller;
+#endif
+	dev->change_mtu = b44_change_mtu;
+#else
 	dev->netdev_ops = &b44_netdev_ops;
 	netif_napi_add(dev, &bp->napi, b44_poll, 64);
 	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#endif
 	dev->irq = sdev->irq;
 	SET_ETHTOOL_OPS(dev, &b44_ethtool_ops);
 
--- a/net/mac80211/iface.c	2009-01-28 11:38:45.000000000 -0800
+++ b/net/mac80211/iface.c	2009-01-28 11:42:08.000000000 -0800
@@ -591,6 +591,7 @@
 	dev_mc_sync(local->mdev, dev);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ieee80211_netdev_ops = {
 	.ndo_open		= ieee80211_open,
 	.ndo_stop		= ieee80211_stop,
@@ -599,13 +600,25 @@
 	.ndo_change_mtu 	= ieee80211_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 };
+#endif
 
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &ieee80211_netdev_ops;
+#else
+	dev->hard_start_xmit = ieee80211_subif_start_xmit;
+	dev->set_multicast_list = ieee80211_set_multicast_list;
+	dev->change_mtu = ieee80211_change_mtu;
+	dev->open = ieee80211_open;
+	dev->stop = ieee80211_stop;
+	/* we will validate the address ourselves in ->open */
+	dev->validate_addr = NULL;
+#endif
 	dev->wireless_handlers = &ieee80211_iw_handler_def;
 	dev->destructor = free_netdev;
+
 }
 /*
  * Called when the netdev is removed or, by the code below, before
