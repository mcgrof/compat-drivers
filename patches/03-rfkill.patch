rfkill was re-implemented on 2.6.31. We port it to
older kernels with a simple hack, just rename the
module as a new one rfkill_backport, and every
exported symbol gets redefined with a _backport
postfix through compat-2.6.31.h. The changes below
are the ones we could not do through compat-2.6.31.h

Do older kernels have /dev/rfkill ? I not then we can
just keep /dev/rfkill and not /dev/rfkill_backport.

Note that 2.6.31 added netdevice notifier upon interface
dev_open() which on cfg80211 will check if checks to see
if rfkill is enabled (or if the mode of operation is not
supported) on the  cfg80211_netdev_notifier_call() and if
so deny bringing the interface up. This was added via
commit:

3b8bcfd5d31ea0fec58681d035544ace707d2536

Since older kernels will not have the notifier call
on dev_open() if we *really want* to port this we could have
mac80211's subif_open() call :

	ret = call_netdevice_notifiers(NETDEV_PRE_UP, dev);
	ret = notifier_to_errno(ret);
	if (ret)
		return ret;

This would do the policing from within mac80211.

--- a/net/rfkill/Makefile
+++ b/net/rfkill/Makefile
@@ -2,6 +2,6 @@
 # Makefile for the RF switch subsystem.
 #
 
-rfkill-y			+= core.o
-rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
-obj-$(CONFIG_RFKILL)		+= rfkill.o
+rfkill_backport-y			+= core.o
+rfkill_backport-$(CONFIG_RFKILL_BACKPORT_INPUT)	+= input.o
+obj-$(CONFIG_RFKILL_BACKPORT)		+= rfkill_backport.o
--- a/net/rfkill/input.c	2009-07-07 17:27:09.290706860 -0700
+++ b/net/rfkill/input.c	2009-07-07 17:26:57.195684653 -0700
@@ -17,7 +17,11 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/init.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 #include <linux/sched.h>
 
 #include "rfkill.h"
@@ -229,7 +233,7 @@ static int rfkill_connect(struct input_h
 
 	handle->dev = dev;
 	handle->handler = handler;
-	handle->name = "rfkill";
+	handle->name = "rfkill_backport";
 
 	/* causes rfkill_start() to be called */
 	error = input_register_handle(handle);
--- a/net/rfkill/core.c	2009-10-06 12:53:52.000000000 -0400
+++ b/net/rfkill/core.c	2009-10-06 12:53:53.000000000 -0400
@@ -26,7 +26,7 @@
 #include <linux/capability.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/rfkill.h>
+#include <linux/rfkill_backport.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/miscdevice.h>
@@ -62,7 +62,7 @@
 	const struct rfkill_ops	*ops;
 	void			*data;
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 	struct led_trigger	led_trigger;
 	const char		*ledtrigname;
 #endif
@@ -123,7 +123,7 @@
 static bool rfkill_epo_lock_active;
 
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 static void rfkill_led_trigger_event(struct rfkill *rfkill)
 {
 	struct led_trigger *trigger;
@@ -317,7 +317,7 @@
 	rfkill_event(rfkill);
 }
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 static atomic_t rfkill_input_disabled = ATOMIC_INIT(0);
 
 /**
@@ -779,7 +779,7 @@
 }
 
 static struct class rfkill_class = {
-	.name		= "rfkill",
+	.name		= "rfkill_backport",
 	.dev_release	= rfkill_release,
 	.dev_attrs	= rfkill_dev_attrs,
 	.dev_uevent	= rfkill_dev_uevent,
@@ -925,7 +925,7 @@
 	if (!rfkill->persistent || rfkill_epo_lock_active) {
 		schedule_work(&rfkill->sync_work);
 	} else {
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 		bool soft_blocked = !!(rfkill->state & RFKILL_BLOCK_SW);
 
 		if (!atomic_read(&rfkill_input_disabled))
@@ -1153,7 +1153,7 @@
 	list_for_each_entry_safe(ev, tmp, &data->events, list)
 		kfree(ev);
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	if (data->input_handler)
 		if (atomic_dec_return(&rfkill_input_disabled) == 0)
 			printk(KERN_DEBUG "rfkill: input handler enabled\n");
@@ -1164,7 +1164,7 @@
 	return 0;
 }
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 static long rfkill_fop_ioctl(struct file *file, unsigned int cmd,
 			     unsigned long arg)
 {
@@ -1197,7 +1197,7 @@
 	.write		= rfkill_fop_write,
 	.poll		= rfkill_fop_poll,
 	.release	= rfkill_fop_release,
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	.unlocked_ioctl	= rfkill_fop_ioctl,
 	.compat_ioctl	= rfkill_fop_ioctl,
 #endif
@@ -1227,7 +1227,7 @@
 		goto out;
 	}
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	error = rfkill_handler_init();
 	if (error) {
 		misc_deregister(&rfkill_miscdev);
@@ -1243,7 +1243,7 @@
 
 static void __exit rfkill_exit(void)
 {
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	rfkill_handler_exit();
 #endif
 	misc_deregister(&rfkill_miscdev);
--- a/include/linux/rfkill_backport.h	2009-09-13 13:28:21.286436755 -0700
+++ b/include/linux/rfkill_backport.h	2009-09-13 13:28:54.665495610 -0700
@@ -20,6 +20,7 @@
  */
 
 #include <linux/types.h>
+#include <linux/compat.h>
 
 /* define userspace visible states */
 #define RFKILL_STATE_SOFT_BLOCKED	0
@@ -148,7 +149,7 @@
 	int	(*set_block)(void *data, bool blocked);
 };
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_MODULE_BACKPORT)
 /**
  * rfkill_alloc - allocate rfkill structure
  * @name: name of the struct -- the string is not copied internally
@@ -355,7 +356,7 @@
 #endif /* RFKILL || RFKILL_MODULE */
 
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 /**
  * rfkill_get_led_trigger_name - Get the LED trigger name for the button's LED.
  * This function might return a NULL pointer if registering of the
--- a/net/wireless/core.h	2009-07-07 13:32:53.367707921 -0700
+++ b/net/wireless/core.h	2009-07-07 13:32:53.943703622 -0700
@@ -11,7 +11,11 @@
 #include <linux/kref.h>
 #include <linux/rbtree.h>
 #include <linux/debugfs.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 #include <linux/workqueue.h>
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
--- a/drivers/net/wireless/ath/ath9k/hw.c	2009-12-10 08:43:21.000000000 -0800
+++ b/drivers/net/wireless/ath/ath9k/hw.c	2009-12-10 08:43:22.000000000 -0800
@@ -3260,7 +3260,7 @@
 
 	pCap->hw_caps |= ATH9K_HW_CAP_ENHANCEDPM;
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))
 	ah->rfsilent = ah->eep_ops->get_eeprom(ah, EEP_RF_SILENT);
 	if (ah->rfsilent & EEP_RFSILENT_ENABLED) {
 		ah->rfkill_gpio =
--- a/drivers/net/wireless/ath/ath5k/base.h
+++ b/drivers/net/wireless/ath/ath5k/base.h
@@ -46,7 +46,11 @@
 #include <linux/wireless.h>
 #include <linux/if_ether.h>
 #include <linux/leds.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 
 #include "ath5k.h"
 #include "debug.h"
